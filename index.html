<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Spin & Glow Wheel</title>
  <style>
    body {
      margin: 0;
      background: radial-gradient(circle at center, #1a0033, #0a0011);
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }
    canvas {
      display: block;
      touch-action: none; /* prevents pinch/zoom on touch devices */
    }
    #muteBtn {
      position: absolute;
      top: 15px;
      right: 15px;
      padding: 10px 18px;
      border: none;
      border-radius: 20px;
      background: #fff;
      color: #333;
      font-size: 16px;
      cursor: pointer;
      box-shadow: 0 0 8px rgba(0,0,0,0.3);
    }
  </style>
</head>
<body>
  <button id="muteBtn">ðŸ”Š Sound On</button>
  <canvas id="wheelCanvas" width="600" height="600"></canvas>

  <script>
    const canvas = document.getElementById("wheelCanvas");
    const ctx = canvas.getContext("2d");
    const muteBtn = document.getElementById("muteBtn");

    const radius = 250; // fixed, never resizes
    const colors = ["#ff007f", "#ff7f00", "#ffff00", "#00ff00", "#00ffff", "#0000ff", "#8b00ff"];

    // Musical notes
    const notes = [261.63, 293.66, 329.63, 392.0, 440.0, 493.88, 523.25];
    let audioCtx = null;
    let soundEnabled = true;

    let angle = 0;
    let spinSpeed = 0;
    const friction = 0.985;

    let isDragging = false;
    let lastAngle = 0;
    let lastTime = 0;

    // glow pulse
    let glowPulseTime = 0;

    // track slice for sound
    let lastSlice = null;

    function getPointerAngle(x, y) {
      const rect = canvas.getBoundingClientRect();
      const cx = rect.left + canvas.width / 2;
      const cy = rect.top + canvas.height / 2;
      return Math.atan2(y - cy, x - cx);
    }

    function drawWheel() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const x = canvas.width / 2;
      const y = canvas.height / 2;
      const numSlices = colors.length;

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);

      glowPulseTime += 0.02;
      const pulse = 20 + Math.sin(glowPulseTime) * 10;

      for (let i = 0; i < numSlices; i++) {
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(0, 0, radius, (i * 2 * Math.PI) / numSlices, ((i + 1) * 2 * Math.PI) / numSlices);
        ctx.closePath();
        ctx.fillStyle = colors[i];
        ctx.shadowColor = colors[i];
        ctx.shadowBlur = pulse;
        ctx.fill();
      }

      ctx.beginPath();
      ctx.arc(0, 0, radius + 5, 0, 2 * Math.PI);
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 5;
      ctx.shadowColor = "#fff";
      ctx.shadowBlur = pulse + 20;
      ctx.stroke();

      ctx.restore();
    }

    function animate() {
      if (!isDragging) {
        angle += spinSpeed;
        spinSpeed *= friction;
      }

      // detect slice & play sound
      const numSlices = colors.length;
      const normalized = ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
      const currentSlice = Math.floor((normalized / (2 * Math.PI)) * numSlices);

      if (currentSlice !== lastSlice && spinSpeed > 0.05) {
        playTone(notes[currentSlice % notes.length], 0.15);
        lastSlice = currentSlice;
      }

      drawWheel();
      requestAnimationFrame(animate);
    }

    // sound helper
    function playTone(freq, duration) {
      if (!soundEnabled) return;
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = "sine";
      osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
      gain.gain.setValueAtTime(0.15, audioCtx.currentTime);

      osc.connect(gain);
      gain.connect(audioCtx.destination);

      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }

    // gestures
    function pointerDown(e) {
      isDragging = true;
      lastAngle = getPointerAngle(
        e.clientX || e.touches[0].clientX,
        e.clientY || e.touches[0].clientY
      );
      lastTime = Date.now();
      spinSpeed = 0; // stop auto spin while dragging
    }

    function pointerMove(e) {
      if (!isDragging) return;
      const currentAngle = getPointerAngle(
        e.clientX || e.touches[0].clientX,
        e.clientY || e.touches[0].clientY
      );
      const now = Date.now();
      const deltaAngle = currentAngle - lastAngle;

      // apply exact finger movement
      angle += deltaAngle;
      // compute speed for when they let go
      spinSpeed = deltaAngle / ((now - lastTime) / 1000);

      lastAngle = currentAngle;
      lastTime = now;
    }

    function pointerUp() {
      isDragging = false;
    }

    // mute toggle
    muteBtn.addEventListener("click", () => {
      soundEnabled = !soundEnabled;
      muteBtn.textContent = soundEnabled ? "ðŸ”Š Sound On" : "ðŸ”‡ Sound Off";
    });

    // bind mouse + touch
    canvas.addEventListener("mousedown", pointerDown);
    canvas.addEventListener("mousemove", pointerMove);
    canvas.addEventListener("mouseup", pointerUp);

    canvas.addEventListener("touchstart", pointerDown);
    canvas.addEventListener("touchmove", pointerMove);
    canvas.addEventListener("touchend", pointerUp);

    animate();
  </script>
</body>
</html>
