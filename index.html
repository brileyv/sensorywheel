<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Spin & Glow Wheel</title>
  <style>
    body {
      margin: 0;
      background: radial-gradient(circle at center, #1a0033, #0a0011);
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }
    canvas {
      display: block;
      touch-action: none; /* prevents pinch/zoom */
    }
    #muteBtn {
      position: absolute;
      top: 15px;
      right: 15px;
      padding: 10px 18px;
      border: none;
      border-radius: 20px;
      background: #fff;
      color: #333;
      font-size: 16px;
      cursor: pointer;
      box-shadow: 0 0 8px rgba(0,0,0,0.3);
    }
    #volumeSlider {
      position: absolute;
      top: 55px;
      right: 15px;
      width: 120px;
    }
  </style>
</head>
<body>
  <button id="muteBtn">ðŸ”Š Sound On</button>
  <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.5">
  <canvas id="wheelCanvas"></canvas>

  <script>
    const canvas = document.getElementById("wheelCanvas");
    const ctx = canvas.getContext("2d");
    const muteBtn = document.getElementById("muteBtn");
    const volumeSlider = document.getElementById("volumeSlider");

    // Wheel radius
    let radius = 100; // safe default

    // Resize canvas fullscreen
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      radius = Math.min(canvas.width, canvas.height) * 0.45;
    }
    window.addEventListener("resize", resizeCanvas);

    const colors = ["#ff007f", "#ff7f00", "#ffff00", "#00ff00", "#00ffff", "#0000ff", "#8b00ff"];

    // Notes
    const notes = [261.63, 293.66, 329.63, 392.0, 440.0, 493.88, 523.25];
    const counterNotes = [174.61, 196.0, 220.0, 246.94, 261.63, 293.66, 329.63];

    let audioCtx = null;
    let masterGain = null;
    let soundEnabled = true;
    let volume = 0.5;

    let angle = 0;
    let spinSpeed = 0;
    const friction = 0.985;

    let isDragging = false;
    let lastAngle = 0;
    let lastTime = 0;

    let glowPulseTime = 0;
    let lastSlice = null;
    let lastSoundTime = 0; // for throttling sounds

    function getPointerAngle(x, y) {
      const rect = canvas.getBoundingClientRect();
      const cx = rect.left + canvas.width / 2;
      const cy = rect.top + canvas.height / 2;
      return Math.atan2(y - cy, x - cx);
    }

    function drawWheel() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const x = canvas.width / 2;
      const y = canvas.height / 2;
      const numSlices = colors.length;

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);

      glowPulseTime += 0.02;
      const pulse = 20 + Math.sin(glowPulseTime) * 10;

      for (let i = 0; i < numSlices; i++) {
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(0, 0, radius, (i * 2 * Math.PI) / numSlices, ((i + 1) * 2 * Math.PI) / numSlices);
        ctx.closePath();
        ctx.fillStyle = colors[i];
        ctx.shadowColor = colors[i];
        ctx.shadowBlur = pulse;
        ctx.fill();
      }

      ctx.beginPath();
      ctx.arc(0, 0, radius + 5, 0, 2 * Math.PI);
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 5;
      ctx.shadowColor = "#fff";
      ctx.shadowBlur = pulse + 20;
      ctx.stroke();

      ctx.restore();
    }

    function animate() {
      if (!isDragging) {
        angle += spinSpeed;
        spinSpeed *= friction;
      }

      const numSlices = colors.length;
      const normalized = ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
      const currentSlice = Math.floor((normalized / (2 * Math.PI)) * numSlices);

      const now = performance.now();
      if (currentSlice !== lastSlice && Math.abs(spinSpeed) > 0.05 && now - lastSoundTime > 100) {
        if (spinSpeed > 0) {
          playTone(notes[currentSlice % notes.length], 0.2, "sine", "cw");
        } else {
          playTone(counterNotes[currentSlice % counterNotes.length], 0.6, "triangle", "ccw");
        }
        lastSlice = currentSlice;
        lastSoundTime = now;
      }

      drawWheel();
      requestAnimationFrame(animate);
    }

    function playTone(freq, duration, type, direction = "cw") {
      if (!soundEnabled) return;
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = volume;
        masterGain.connect(audioCtx.destination);
      }

      if (direction === "cw") {
        // CLOCKWISE = musical tone
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);

        gain.gain.setValueAtTime(0, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.02);
        gain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + duration - 0.05);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start();
        osc.stop(audioCtx.currentTime + duration);
      } else {
        // COUNTERCLOCKWISE = soft whoosh
        const bufferSize = 2 * audioCtx.sampleRate;
        const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const output = noiseBuffer.getChannelData(0);

        for (let i = 0; i < bufferSize; i++) {
          output[i] = Math.random() * 2 - 1;
        }

        const noise = audioCtx.createBufferSource();
        noise.buffer = noiseBuffer;

        const filter = audioCtx.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.setValueAtTime(800, audioCtx.currentTime);

        const gain = audioCtx.createGain();

        // Longer envelope for smoothness
        gain.gain.setValueAtTime(0, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0.12, audioCtx.currentTime + 0.1);
        gain.gain.linearRampToValueAtTime(0.12, audioCtx.currentTime + duration - 0.2);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration);

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);

        noise.start();
        noise.stop(audioCtx.currentTime + duration);
      }
    }

    // Pointer handling
    function pointerDown(e) {
      isDragging = true;
      lastAngle = getPointerAngle(
        e.clientX || e.touches[0].clientX,
        e.clientY || e.touches[0].clientY
      );
      lastTime = Date.now();
      spinSpeed = 0;
    }

    function pointerMove(e) {
      if (!isDragging) return;
      const currentAngle = getPointerAngle(
        e.clientX || e.touches[0].clientX,
        e.clientY || e.touches[0].clientY
      );
      const now = Date.now();
      const deltaAngle = currentAngle - lastAngle;

      angle += deltaAngle;
      spinSpeed = deltaAngle / ((now - lastTime) / 1000);

      lastAngle = currentAngle;
      lastTime = now;
    }

    function pointerUp() {
      isDragging = false;
    }

    // Controls
    muteBtn.addEventListener("click", () => {
      soundEnabled = !soundEnabled;
      muteBtn.textContent = soundEnabled ? "ðŸ”Š Sound On" : "ðŸ”‡ Sound Off";
    });

    volumeSlider.addEventListener("input", (e) => {
      volume = parseFloat(e.target.value);
      if (masterGain) {
        masterGain.gain.value = volume;
      }
    });

    canvas.addEventListener("mousedown", pointerDown);
    canvas.addEventListener("mousemove", pointerMove);
    canvas.addEventListener("mouseup", pointerUp);

    canvas.addEventListener("touchstart", pointerDown);
    canvas.addEventListener("touchmove", pointerMove);
    canvas.addEventListener("touchend", pointerUp);

    // âœ… Ensure resize before animation
    resizeCanvas();
    animate();
  </script>
</body>
</html>
