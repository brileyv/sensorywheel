<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Spin Sensory Wheel</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #0d001f;
      font-family: Arial, sans-serif;
      touch-action: none;
    }

    canvas {
      display: block;
    }

    /* Upgrade Button */
    #upgradeBtn {
      position: fixed;
      bottom: 60px;
      right: 10px;
      background: linear-gradient(45deg, #ff00cc, #3333ff);
      color: white;
      font-weight: bold;
      font-size: 16px;
      border: none;
      border-radius: 25px;
      padding: 12px 18px;
      cursor: pointer;
      z-index: 10;
    }

    /* Control Buttons */
    #controls {
      position: fixed;
      bottom: 110px;
      right: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 10;
    }

    .control-btn {
      background: #333;
      color: white;
      font-size: 15px;
      border: none;
      border-radius: 20px;
      padding: 10px 15px;
      cursor: pointer;
    }

    /* Instructions */
    #instructions {
      position: fixed;
      bottom: 8px;
      width: 100%;
      text-align: center;
      font-size: 13px;
      color: rgba(255,255,255,0.8);
      z-index: 5;
    }
  </style>
</head>
<body>
  <canvas id="wheelCanvas"></canvas>

  <div id="controls">
    <button id="soundBtn" class="control-btn">ðŸ”Š Sound On</button>
    <button id="lockBtn" class="control-btn">ðŸ”’ Enable Baby Lock</button>
  </div>

  <button id="upgradeBtn">Upgrade Â· $5 for Life</button>

  <div id="instructions">
    Hold mute 3s for volume settings Â· Hold Back + Overview buttons to exit Baby Lock
  </div>

  <script>
    const canvas = document.getElementById("wheelCanvas");
    const ctx = canvas.getContext("2d");
    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    // Resize handler
    window.addEventListener("resize", () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    });

    // Wheel state
    let wheelAngle = 0;
    let isDragging = false;
    let lastX = null;
    let velocity = 0;
    let activePointer = null;

    // Bubble state
    const bubbles = [];
    const maxBubbles = 20;

    function createBubble() {
      const x = Math.random() * width;
      const r = 30 + Math.random() * 40; // bigger soapy look
      bubbles.push({
        x,
        y: -r,
        r,
        speed: 0.5 + Math.random() * 1,
        noteIndex: 0
      });
    }

    function drawBubble(b) {
      const gradient = ctx.createRadialGradient(b.x - b.r*0.3, b.y - b.r*0.3, b.r*0.2, b.x, b.y, b.r);
      gradient.addColorStop(0, "rgba(255,255,255,0.8)");
      gradient.addColorStop(0.4, "rgba(173,216,230,0.3)");
      gradient.addColorStop(1, "rgba(255,255,255,0.05)");
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fill();
    }

    // Notes for Do-Re-Mi (C major)
    const notes = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25];
    let noteIndex = 0;

    function playNote(forward=true) {
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      // Set frequency
      osc.frequency.value = notes[noteIndex];
      gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);

      osc.start();
      osc.stop(audioCtx.currentTime + 0.25);

      // Step index
      if (forward) {
        noteIndex = (noteIndex + 1) % notes.length;
      } else {
        noteIndex = (noteIndex - 1 + notes.length) % notes.length;
      }
    }
    // Draw wheel
    function drawWheel() {
      const radius = Math.min(width, height) * 0.35;
      const cx = width / 2;
      const cy = height / 2;
      const segments = 7;
      const colors = ["#ff0000","#ff7f00","#ffff00","#00ff00","#00ffff","#0000ff","#8b00ff"];

      for (let i = 0; i < segments; i++) {
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.arc(cx, cy, radius, wheelAngle + (i * 2 * Math.PI / segments), wheelAngle + ((i+1) * 2 * Math.PI / segments));
        ctx.closePath();
        ctx.fillStyle = colors[i % colors.length];
        ctx.fill();
      }

      // Glow edge
      ctx.strokeStyle = "white";
      ctx.lineWidth = 4;
      ctx.shadowBlur = 30;
      ctx.shadowColor = "#fff";
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    // Bubble pop detection
    function popBubble(x, y) {
      for (let i = bubbles.length - 1; i >= 0; i--) {
        const b = bubbles[i];
        const dx = x - b.x;
        const dy = y - b.y;
        if (Math.sqrt(dx*dx + dy*dy) < b.r) {
          playNote(true);
          bubbles.splice(i, 1);
          break;
        }
      }
    }

    // Wheel spin
    canvas.addEventListener("pointerdown", (e) => {
      if (activePointer === null) {
        isDragging = true;
        lastX = e.clientX;
        activePointer = e.pointerId;
      }
    });

    canvas.addEventListener("pointermove", (e) => {
      if (isDragging && e.pointerId === activePointer) {
        const dx = e.clientX - lastX;
        velocity = dx * 0.002;
        wheelAngle += velocity;
        lastX = e.clientX;

        if (velocity > 0) {
          playNote(true);
        } else if (velocity < 0) {
          playNote(false);
        }
      }
    });

    canvas.addEventListener("pointerup", (e) => {
      if (e.pointerId === activePointer) {
        isDragging = false;
        activePointer = null;
      } else {
        popBubble(e.clientX, e.clientY);
      }
    });

    // Bubble spawning loop
    setInterval(() => {
      if (bubbles.length < maxBubbles) {
        createBubble();
      }
    }, 600);

    // Animation loop
    function animate() {
      ctx.clearRect(0,0,width,height);

      // Draw wheel
      drawWheel();

      // Update & draw bubbles
      for (let i = bubbles.length - 1; i >= 0; i--) {
        const b = bubbles[i];
        b.y += b.speed;
        drawBubble(b);
        if (b.y - b.r > height) {
          bubbles.splice(i, 1);
        }
      }

      requestAnimationFrame(animate);
    }
    animate();

    // Buttons
    const soundBtn = document.getElementById("soundBtn");
    const lockBtn = document.getElementById("lockBtn");
    const upgradeBtn = document.getElementById("upgradeBtn");
    let soundOn = true;
    let babyLock = false;

    soundBtn.addEventListener("click", () => {
      soundOn = !soundOn;
      soundBtn.textContent = soundOn ? "ðŸ”Š Sound On" : "ðŸ”‡ Sound Off";
    });

    lockBtn.addEventListener("click", () => {
      if (!babyLock) {
        alert("Baby Lock enabled! Hold both Back + Overview to exit.");
        babyLock = true;
        lockBtn.textContent = "ðŸ”“ Disable Baby Lock";
      } else {
        babyLock = false;
        lockBtn.textContent = "ðŸ”’ Enable Baby Lock";
      }
    });

    upgradeBtn.addEventListener("click", () => {
      alert("âœ… You're now ad free, and Baby Lock is available!");
    });

    // Fix note playback to respect mute
    function playNote(forward=true) {
      if (!soundOn) return;
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      osc.type = "sine"; // smoother tone
      osc.frequency.value = notes[noteIndex];
      gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);

      osc.start();
      osc.stop(audioCtx.currentTime + 0.25);

      if (forward) {
        noteIndex = (noteIndex + 1) % notes.length;
      } else {
        noteIndex = (noteIndex - 1 + notes.length) % notes.length;
      }
    }
  </script>
</body>
</html>
