<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bubble Wheel</title>
  <style>
    body {
      margin: 0;
      background: #0b0015;
      overflow: hidden;
      touch-action: none;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
let width = window.innerWidth;
let height = window.innerHeight;
canvas.width = width;
canvas.height = height;

// 🎡 Wheel setup
let wheelRadius = Math.min(width, height) / 3;
let wheelAngle = 0;
let isDragging = false;
let lastAngle = null;

// 🎶 Scale notes (C major do-re-mi…)
const notes = [261.63, 293.66, 329.63, 349.23, 392.0, 440.0, 493.88, 523.25];
let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let bubbleNoteIndex = 0;

// 🫧 Bubbles
let bubbles = [];
class Bubble {
  constructor(x, y, r, speed) {
    this.x = x;
    this.y = y;
    this.r = r;
    this.speed = speed;
  }
  update() {
    this.y += this.speed;
    if (this.y - this.r > height) {
      this.reset();
    }
  }
  reset() {
    this.x = Math.random() * width;
    this.y = -this.r;
    this.r = 30 + Math.random() * 40;
    this.speed = 1 + Math.random() * 2;
  }
  draw() {
    let gradient = ctx.createRadialGradient(this.x - this.r/3, this.y - this.r/3, this.r/5, this.x, this.y, this.r);
    gradient.addColorStop(0, "rgba(255,255,255,0.9)");
    gradient.addColorStop(0.3, "rgba(200,200,255,0.3)");
    gradient.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
    ctx.fill();
  }
}

for (let i = 0; i < 15; i++) {
  let r = 30 + Math.random() * 40;
  let x = Math.random() * width;
  let y = Math.random() * height;
  let speed = 1 + Math.random() * 2;
  bubbles.push(new Bubble(x, y, r, speed));
}

// 🎵 Play sine tone
function playNote(freq) {
  let osc = audioCtx.createOscillator();
  let gain = audioCtx.createGain();
  osc.type = "sine";
  osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
  gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
  osc.connect(gain).connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + 0.3);
}

// 🖱️ / 👆 Events
canvas.addEventListener("pointerdown", (e) => {
  let dx = e.clientX - width/2;
  let dy = e.clientY - height/2;
  let dist = Math.sqrt(dx*dx + dy*dy);
  if (dist < wheelRadius) {
    isDragging = true;
    lastAngle = Math.atan2(dy, dx);
  } else {
    checkBubbleClick(e.clientX, e.clientY);
  }
});
canvas.addEventListener("pointermove", (e) => {
  if (!isDragging) return;
  let dx = e.clientX - width/2;
  let dy = e.clientY - height/2;
  let angle = Math.atan2(dy, dx);
  let delta = angle - lastAngle;
  wheelAngle += delta;
  lastAngle = angle;
  if (delta > 0) { // clockwise
    playNote(notes[Math.floor((wheelAngle*4) % notes.length)]);
  } else { // counterclockwise
    playNote(notes[Math.floor((notes.length - (wheelAngle*4) % notes.length) % notes.length)]);
  }
});
canvas.addEventListener("pointerup", () => { isDragging = false; });

function checkBubbleClick(x, y) {
  for (let b of bubbles) {
    let dx = x - b.x;
    let dy = y - b.y;
    if (dx*dx + dy*dy < b.r*b.r) {
      playNote(notes[bubbleNoteIndex]);
      bubbleNoteIndex = (bubbleNoteIndex + 1) % notes.length;
      b.reset();
      break;
    }
  }
}

// 🎨 Draw loop
function draw() {
  ctx.clearRect(0, 0, width, height);

  // Bubbles
  for (let b of bubbles) {
    b.update();
    b.draw();
  }

  // Wheel
  ctx.save();
  ctx.translate(width/2, height/2);
  ctx.rotate(wheelAngle);
  let colors = ["red","orange","yellow","green","cyan","blue","indigo","violet"];
  for (let i = 0; i < 8; i++) {
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.arc(0,0,wheelRadius,(i*Math.PI/4),((i+1)*Math.PI/4));
    ctx.closePath();
    ctx.fillStyle = colors[i];
    ctx.fill();
  }
  ctx.strokeStyle = "white";
  ctx.lineWidth = 5;
  ctx.stroke();
  ctx.restore();

  requestAnimationFrame(draw);
}
draw();

window.addEventListener("resize", () => {
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;
  wheelRadius = Math.min(width, height) / 3;
});
</script>
</body>
</html>
