<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Spin Sensory Wheel</title>
  <style>
    body { margin:0; background:#0a0011; overflow:hidden; }
    canvas { display:block; touch-action:none; }

    #muteBtn {
      position:absolute; top:15px; right:15px;
      padding:10px 20px;
      border:none; border-radius:20px; background:#fff;
      font-size:16px; cursor:pointer;
      box-shadow:0 0 6px rgba(0,0,0,0.3);
    }
    #volumeSlider {
      position:absolute; top:65px; right:15px;
      width:220px; height:30px;
    }

    #upgradeBtn, #babyLockBtn {
      position:absolute; right:15px;
      font-size:20px; font-weight:bold;
      padding:16px 28px;
      border:none; border-radius:35px;
      color:white; cursor:pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }
    #upgradeBtn {
      bottom:20px;
      background: linear-gradient(135deg, #4facfe 0%, #8e2de2 100%);
      box-shadow: 0 0 15px rgba(142,45,226,0.6);
    }
    #babyLockBtn {
      bottom:80px; left:15px; right:auto;
      background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
      box-shadow: 0 0 15px rgba(56,249,215,0.6);
      display:none;
    }
    #babyLockInfo {
      display:none; position:absolute; bottom:0; left:0; right:0;
      padding:10px; text-align:center; font-size:16px; color:#fff;
      background:rgba(0,0,0,0.5);
    }
  </style>
</head>
<body>
  <button id="muteBtn">ðŸ”Š Sound On</button>
  <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.5">
  <button id="upgradeBtn">Upgrade for Baby Lock + No Ads Â· $5 for Life</button>
  <button id="babyLockBtn">Enable Baby Lock</button>
  <div id="babyLockInfo">ðŸ”’ Baby Lock enabled. To exit: Hold Back + Overview buttons.</div>
  <canvas id="wheelCanvas"></canvas>

  <script type="module">
    import { showBanner, hideBanner } from "./ads.js";
    import { initIAP, buyUnlock, checkUnlock, enableBabyLock } from "./iap.js";

    const canvas=document.getElementById("wheelCanvas"),ctx=canvas.getContext("2d");
    const muteBtn=document.getElementById("muteBtn"),volumeSlider=document.getElementById("volumeSlider");

    let radius=100,audioCtx=null,masterGain=null,soundEnabled=true,volume=0.5;
    let angle=0,spinSpeed=0,friction=0.985,isDragging=false,lastAngle=0,lastTime=0,glowPulseTime=0,lastSlice=null,lastSoundTime=0;

    const colors=["#ff007f","#ff7f00","#ffff00","#00ff00","#00ffff","#0000ff","#8b00ff"];
    const notes=[261.63,293.66,329.63,392.0,440.0,493.88,523.25];

    // --- Bubbles ---
    let bubbles = [];
    function createBubblesFromSpin() {
      if (Math.abs(spinSpeed) > 0.01 && Math.random() < Math.min(Math.abs(spinSpeed) * 0.05, 0.3)) {
        const angleOffset = angle + (Math.random() * 0.5 - 0.25); // near spin angle
        const spawnRadius = radius + 10;
        const bx = canvas.width/2 + Math.cos(angleOffset) * spawnRadius;
        const by = canvas.height/2 + Math.sin(angleOffset) * spawnRadius;

        const size = 60 + Math.random() * 40;

        const speed = 2 + Math.random() * 2;
        const vx = Math.cos(angleOffset) * speed;
        const vy = Math.sin(angleOffset) * speed;

        bubbles.push({ x:bx, y:by, r:size, vx:vx, vy:vy, opacity:0.6 + Math.random()*0.3, popped:false });
      }
    }

    function drawBubbles() {
      bubbles.forEach((b, i) => {
        if (!b.popped) {
          const grad = ctx.createRadialGradient(b.x, b.y, b.r * 0.6, b.x, b.y, b.r);
          grad.addColorStop(0, "rgba(255,255,255,0.05)");
          grad.addColorStop(0.7, "rgba(255,255,255,0.1)");
          grad.addColorStop(1, "rgba(255,255,255,0.25)");

          ctx.beginPath();
          ctx.arc(b.x, b.y, b.r, 0, 2 * Math.PI);
          ctx.fillStyle = grad;
          ctx.fill();

          const rainbow = ctx.createLinearGradient(b.x - b.r, b.y - b.r, b.x + b.r, b.y + b.r);
          rainbow.addColorStop(0, "rgba(255,0,255,0.25)");
          rainbow.addColorStop(0.25, "rgba(0,255,255,0.25)");
          rainbow.addColorStop(0.5, "rgba(0,255,0,0.2)");
          rainbow.addColorStop(0.75, "rgba(255,255,0,0.25)");
          rainbow.addColorStop(1, "rgba(255,0,0,0.25)");

          ctx.strokeStyle = rainbow;
          ctx.lineWidth = 2;
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(b.x - b.r * 0.3, b.y - b.r * 0.3, b.r * 0.2, 0, 2 * Math.PI);
          ctx.fillStyle = "rgba(255,255,255,0.35)";
          ctx.fill();

          b.x += b.vx;
          b.y += b.vy;

          if (b.x + b.r < 0 || b.x - b.r > canvas.width ||
              b.y + b.r < 0 || b.y - b.r > canvas.height) {
            bubbles.splice(i, 1);
          }
        }
      });
    }

    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      bubbles.forEach(b => {
        if (!b.popped) {
          const dist = Math.hypot(b.x - x, b.y - y);
          if (dist < b.r) { b.popped = true; playBubblePop(); }
        }
      });
    });

    function playBubblePop() {
      if (!soundEnabled || !audioCtx) return;
      const now = audioCtx.currentTime;

      // noise burst
      const bufferSize = audioCtx.sampleRate * 0.1;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = (Math.random()*2-1)*(1 - i/bufferSize);
      const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
      const noiseGain = audioCtx.createGain();
      noiseGain.gain.setValueAtTime(0.2, now);
      noiseGain.gain.exponentialRampToValueAtTime(0.001, now+0.1);
      noise.connect(noiseGain).connect(masterGain);
      noise.start(now); noise.stop(now+0.1);

      // blip
      const osc = audioCtx.createOscillator();
      osc.type="sine"; osc.frequency.setValueAtTime(800, now);
      osc.frequency.exponentialRampToValueAtTime(200, now+0.15);
      const oscGain = audioCtx.createGain();
      oscGain.gain.setValueAtTime(0.2, now);
      oscGain.gain.exponentialRampToValueAtTime(0.001, now+0.15);
      osc.connect(oscGain).connect(masterGain);
      osc.start(now); osc.stop(now+0.15);
    }
    function resizeCanvas(){
      canvas.width=window.innerWidth||600;
      canvas.height=window.innerHeight||600;
      const m=Math.min(canvas.width,canvas.height);
      radius=(m>0?m:600)*0.45;
    }
    window.addEventListener("resize",resizeCanvas);

    function getPointerAngle(x,y){
      const r=canvas.getBoundingClientRect(),
            cx=r.left+canvas.width/2,
            cy=r.top+canvas.height/2;
      return Math.atan2(y-cy,x-cx);
    }

    function drawWheel(){
      ctx.save();
      ctx.translate(canvas.width/2,canvas.height/2);
      ctx.rotate(angle);

      glowPulseTime += 0.02;
      const pulse = 50 + Math.sin(glowPulseTime) * 10;

      ctx.beginPath();
      ctx.arc(0, 0, radius + 12, 0, 2 * Math.PI);
      ctx.strokeStyle = "white";
      ctx.lineWidth = 4;
      ctx.shadowColor = "white";
      ctx.shadowBlur = pulse * 1.5;
      ctx.stroke();

      for(let i=0;i<colors.length;i++){
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,radius,(i*2*Math.PI)/colors.length,((i+1)*2*Math.PI)/colors.length);
        ctx.closePath();
        ctx.fillStyle = colors[i];
        ctx.shadowColor = colors[i];
        ctx.shadowBlur = pulse;
        ctx.fill();
      }
      ctx.restore();
    }

    function animate(){
      if(!isDragging){ angle+=spinSpeed; spinSpeed*=friction; }

      createBubblesFromSpin(); // bubbles spit from wheel

      const normalized=((angle%(2*Math.PI))+2*Math.PI)%(2*Math.PI);
      const currentSlice=Math.floor((normalized/(2*Math.PI))*colors.length);
      const now=performance.now();

      if(currentSlice!==lastSlice && Math.abs(spinSpeed)>0.05 && now-lastSoundTime>100){
        if(spinSpeed>0){ playTone(notes[currentSlice%notes.length],0.25,"sine","cw"); }
        else { playTone(notes[currentSlice%notes.length]/2,0.25,"triangle","ccw"); }
        lastSlice=currentSlice; lastSoundTime=now;
      }

      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawBubbles(); drawWheel();
      requestAnimationFrame(animate);
    }

    function playTone(freq,duration,type,dir="cw"){
      if(!soundEnabled) return;
      if(!audioCtx){ audioCtx=new (window.AudioContext||window.webkitAudioContext)();
        masterGain=audioCtx.createGain(); masterGain.gain.value=volume;
        masterGain.connect(audioCtx.destination);}
      const osc=audioCtx.createOscillator(),gain=audioCtx.createGain();
      osc.type=type; osc.frequency.setValueAtTime(freq,audioCtx.currentTime);
      if(dir==="cw"){ gain.gain.setValueAtTime(0,audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0.15,audioCtx.currentTime+0.02);
        gain.gain.linearRampToValueAtTime(0.15,audioCtx.currentTime+duration-0.05);
        gain.gain.linearRampToValueAtTime(0,audioCtx.currentTime+duration);}
      else { gain.gain.setValueAtTime(0,audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0.18,audioCtx.currentTime+0.01);
        gain.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+duration);}
      osc.connect(gain); gain.connect(masterGain);
      osc.start(); osc.stop(audioCtx.currentTime+duration);
    }

    function pointerDown(e){
      isDragging=true;
      lastAngle=getPointerAngle(e.clientX||e.touches[0].clientX,e.clientY||e.touches[0].clientY);
      lastTime=Date.now(); spinSpeed=0;
    }
    function pointerMove(e){
      if(!isDragging) return;
      const a=getPointerAngle(e.clientX||e.touches[0].clientX,e.clientY||e.touches[0].clientY);
      const now=Date.now(); const delta=a-lastAngle;
      angle+=delta; spinSpeed=delta/((now-lastTime)/1000);
      lastAngle=a; lastTime=now;
    }
    function pointerUp(){ isDragging=false; }

    muteBtn.onclick=()=>{ soundEnabled=!soundEnabled;
      muteBtn.textContent=soundEnabled?"ðŸ”Š Sound On":"ðŸ”‡ Sound Off"; };
    volumeSlider.oninput=e=>{ volume=parseFloat(e.target.value);
      if(masterGain){ masterGain.gain.value=volume; } };

    canvas.addEventListener("mousedown",pointerDown);
    canvas.addEventListener("mousemove",pointerMove);
    canvas.addEventListener("mouseup",pointerUp);
    canvas.addEventListener("touchstart",pointerDown);
    canvas.addEventListener("touchmove",pointerMove);
    canvas.addEventListener("touchend",pointerUp);

    window.onload = async () => {
      resizeCanvas(); animate(); await initIAP();
      const unlocked = await checkUnlock();
      if (!unlocked) { showBanner(); document.getElementById("upgradeBtn").onclick = buyUnlock; }
      else { document.getElementById("upgradeBtn").style.display="none";
             document.getElementById("babyLockBtn").style.display="block";
             document.getElementById("babyLockBtn").onclick=enableBabyLock; }
    };
  </script>
</body>
</html>
