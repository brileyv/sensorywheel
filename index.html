<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spin Sensory Wheel</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #0b0014;
      font-family: Arial, sans-serif;
      color: white;
    }

    canvas {
      display: block;
      margin: auto;
      background: transparent;
    }

    #controls {
      position: fixed;
      bottom: 10px;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      z-index: 10;
    }

    .btn {
      background: rgba(0,0,0,0.7);
      border-radius: 12px;
      padding: 12px 20px;
      font-size: 16px;
      color: white;
      border: none;
      cursor: pointer;
    }

    .btn.upgrade {
      background: linear-gradient(90deg, #7b2ff7, #f107a3);
      font-weight: bold;
    }

    #instructions {
      font-size: 12px;
      color: rgba(255,255,255,0.7);
      margin-top: 4px;
      text-align: center;
    }

    /* Volume button */
    #volumeControls {
      position: fixed;
      top: 15px;
      right: 15px;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
      z-index: 20;
    }
    #volumeBtn, #muteToggle {
      background: rgba(0,0,0,0.7);
      border: none;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      font-size: 20px;
      color: white;
      cursor: pointer;
    }
    #muteToggle, #volumeSlider {
      display: none;
    }
    #volumeSlider {
      width: 120px;
    }

    /* Unlock Modal */
    #unlockModal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 50;
    }
    .modal-content {
      background: #222;
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      color: white;
      max-width: 300px;
      width: 80%;
    }
    #confirmExit {
      margin-top: 15px;
      background: crimson;
      color: white;
      border: none;
      border-radius: 8px;
      padding: 10px 18px;
      font-size: 16px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <div id="volumeControls">
    <button id="volumeBtn">ðŸ”Š</button>
    <button id="muteToggle">ðŸ”‡</button>
    <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.5">
  </div>

  <div id="controls">
    <button id="upgradeBtn" class="btn upgrade">Upgrade for Baby Lock + No Ads Â· $5 for Life</button>
    <div id="instructions">Hold volume button 3s for settings Â· Hold both top corners 3s to exit Baby Lock</div>
  </div>

  <!-- Baby Lock exit modal -->
  <div id="unlockModal">
    <div class="modal-content">
      <p>Exit Baby Lock?</p>
      <button id="confirmExit">Hold to Exit</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    let width, height;
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resize);
    resize();

    // -------- Wheel ----------
    const wheel = {
      x: width / 2,
      y: height / 2,
      radius: Math.min(width, height) / 3,
      angle: 0,
      speed: 0,
      dragging: false,
      lastAngle: 0
    };
    const colors = ["red", "orange", "yellow", "lime", "cyan", "blue", "violet"];

    function drawWheel() {
      const slice = (2 * Math.PI) / colors.length;
      for (let i = 0; i < colors.length; i++) {
        ctx.beginPath();
        ctx.moveTo(wheel.x, wheel.y);
        ctx.arc(wheel.x, wheel.y, wheel.radius, wheel.angle + i * slice, wheel.angle + (i + 1) * slice);
        ctx.closePath();
        ctx.fillStyle = colors[i];
        ctx.fill();
      }
      ctx.beginPath();
      ctx.arc(wheel.x, wheel.y, wheel.radius, 0, 2 * Math.PI);
      ctx.lineWidth = 5;
      ctx.strokeStyle = "white";
      ctx.shadowBlur = 30;
      ctx.shadowColor = "white";
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    // -------- Bubbles ----------
    class Bubble {
      constructor(x, y, radius, speed) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.speed = speed;
        this.alive = true;
      }
      update() {
        this.y += this.speed;
        if (this.y - this.radius > height) this.reset();
      }
      reset() {
        this.x = Math.random() * width;
        this.y = -this.radius;
        this.radius = 25 + Math.random() * 25;
        this.speed = 1 + Math.random() * 1.5;
        this.alive = true;
      }
      draw() {
        const gradient = ctx.createRadialGradient(this.x - this.radius/3, this.y - this.radius/3, this.radius/5, this.x, this.y, this.radius);
        gradient.addColorStop(0, "rgba(255,255,255,0.9)");
        gradient.addColorStop(0.3, "rgba(200,200,255,0.4)");
        gradient.addColorStop(0.8, "rgba(150,150,255,0.2)");
        gradient.addColorStop(1, "rgba(255,255,255,0.05)");
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }
      pop(x, y) {
        const dx = x - this.x;
        const dy = y - this.y;
        return dx * dx + dy * dy <= this.radius * this.radius;
      }
    }
    const bubbles = Array.from({length: 15}, () =>
      new Bubble(Math.random() * width, Math.random() * height, 25 + Math.random()*25, 1 + Math.random()*1.5)
    );

    // -------- Sounds ----------
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let soundOn = true, volume = 0.5;
    const scaleFreqs = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25];
    let noteIndex = 0;
    function playNote(forward = true) {
      if (!soundOn) return;
      const osc = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      osc.connect(gainNode).connect(audioCtx.destination);
      osc.type = "sine";
      osc.frequency.value = scaleFreqs[noteIndex];
      gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.4);
      if (forward) noteIndex = (noteIndex + 1) % scaleFreqs.length;
      else noteIndex = (noteIndex - 1 + scaleFreqs.length) % scaleFreqs.length;
    }

    canvas.addEventListener("click", e => {
      const x = e.clientX, y = e.clientY;
      for (let b of bubbles) {
        if (b.alive && b.pop(x,y)) {
          b.reset();
          playNote(true);
          break;
        }
      }
    });

    // -------- Touch spin --------
    canvas.addEventListener("touchstart", e => {
      const t = e.touches[0];
      const dx = t.clientX - wheel.x;
      const dy = t.clientY - wheel.y;
      if (Math.sqrt(dx*dx + dy*dy) < wheel.radius) {
        wheel.dragging = true;
        wheel.lastAngle = Math.atan2(dy, dx);
      }
    });
    canvas.addEventListener("touchmove", e => {
      if (wheel.dragging) {
        const t = e.touches[0];
        const dx = t.clientX - wheel.x;
        const dy = t.clientY - wheel.y;
        const angle = Math.atan2(dy, dx);
        const delta = angle - wheel.lastAngle;
        wheel.angle += delta;
        wheel.speed = delta;
        wheel.lastAngle = angle;
        playNote(delta > 0);
      }
    });
    canvas.addEventListener("touchend", () => { wheel.dragging = false; });

    // -------- Volume controls --------
    const volumeBtn = document.getElementById("volumeBtn");
    const muteToggle = document.getElementById("muteToggle");
    const volumeSlider = document.getElementById("volumeSlider");
    let holdTimer;
    volumeBtn.addEventListener("mousedown", () => {
      holdTimer = setTimeout(() => {
        muteToggle.style.display = "block";
        volumeSlider.style.display = "block";
      }, 3000);
    });
    volumeBtn.addEventListener("mouseup", () => clearTimeout(holdTimer));
    volumeBtn.addEventListener("mouseleave", () => clearTimeout(holdTimer));
    muteToggle.onclick = () => {
      soundOn = !soundOn;
      muteToggle.textContent = soundOn ? "ðŸ”Š" : "ðŸ”‡";
    };
    volumeSlider.oninput = e => { volume = parseFloat(e.target.value); };

    // -------- Upgrade --------
    let upgraded = false;
    document.getElementById("upgradeBtn").onclick = () => {
      upgraded = true;
      document.getElementById("upgradeBtn").innerText = "You're now ad-free, and Baby Lock is enabled!";
      document.getElementById("upgradeBtn").disabled = true;
    };

    // -------- Baby Lock --------
    let cornerTouchStart = null;
    const unlockModal = document.getElementById("unlockModal");
    const confirmExit = document.getElementById("confirmExit");
    canvas.addEventListener("touchstart", e => {
      const t1 = e.touches[0], t2 = e.touches[1];
      if (e.touches.length === 2) {
        if (t1.clientY < 100 && t2.clientY < 100 && t1.clientX < 100 && t2.clientX > width-100) {
          cornerTouchStart = Date.now();
        }
      }
    });
    canvas.addEventListener("touchend", e => {
      if (cornerTouchStart && Date.now() - cornerTouchStart >= 3000) {
        unlockModal.style.display = "flex";
        setTimeout(() => { if (unlockModal.style.display === "flex") unlockModal.style.display = "none"; }, 10000);
      }
      cornerTouchStart = null;
    });
    let exitHold;
    confirmExit.addEventListener("mousedown", () => {
      exitHold = setTimeout(() => {
        unlockModal.style.display = "none";
        alert("âœ… Baby Lock Disabled");
      }, 2000);
    });
    confirmExit.addEventListener("mouseup", () => clearTimeout(exitHold));
    confirmExit.addEventListener("mouseleave", () => clearTimeout(exitHold));

    // -------- Loop --------
    function loop() {
      ctx.clearRect(0, 0, width, height);
      bubbles.forEach(b => { b.update(); b.draw(); });
      if (!wheel.dragging) { wheel.angle += wheel.speed; wheel.speed *= 0.98; }
      drawWheel();
      requestAnimationFrame(loop);
    }
    loop();
  </script>
</body>
</html>
